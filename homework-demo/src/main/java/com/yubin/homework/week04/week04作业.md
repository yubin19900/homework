作业第一题：并发编程中根据具体场景而定，比如读多写少的场景可以采用乐观锁CAS，共享锁ReentrantReadWriteLock提高效率；使用锁时考虑尽量降低锁粒度，减少资源占用的时间，同时防止死锁发生的几率，此外使用锁时要考虑业务超时锁释放问题，防止死锁，同时锁也需要可重入，已经获取锁线程可以再次获取锁，避免锁释放和获取的资源消耗。
作业第二题：作业2的做法如果细分的话超过代码所示的9中写法，比如使用不同类型的线程池CachedThreadPool、FixedThreadPool、ScheduledThreadPool、SingleThreadExecutor、，使用不同类型的原子类AtomicInteger、AtomicLong、LongAdder,使用不同的并发工具类ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore,代码中有对应的例子，基本上换汤不换药，老师如果有新的思路可以分享一下，我学习一下。
作业第三题：常用的并发工具类有CountDownLatch，CyclicBarrier，ReentrantLock，AtomicLong，LongAdder，ConcurrentHashMap等
ConcurrentHashMap：应用于读多写少的业务场景，保证线程安全，jdk1.7和jdk1.8采用了不同方式保证线程安全，相对于1.7的分段锁，1.8采用了CAS + Synchronized保证了线程安全，因为基于jvm的Synchronized锁比基于api的锁优化空间大；
AtomicLong，LongAdder：原子操作类，多线程情况下保证数据计算的安全行，AtomicLong采用CAS原理，每次操作都会强制刷新内存，保证各线程内存可见，但这种操作往往比较消耗资源，LongAdder作了对应改进，类似与ConcurrentHashMap jdk1.7版本使用了分段的思想，但是这种用空间换时间的做法，提高了吞吐量，同时了提升了内存占用
CountDownLatch，CyclicBarrier：两者都是并发常用的工具类，但是工作的方式有所不同，CountDownLatch是在主线程中阻塞聚合，通过AbstractQueuedSynchronizer实现，而CyclicBarrier是在各个子线程中阻塞回调聚合，通过可重入锁condition的await和signalAll实现，两者多线程协作同步点和原理不一样，此外CyclicBarrier可以重复使用
ReentrantLock：相对于Synchronized而言功能更加丰富，它的加锁和解锁需要手动控制，比较灵活，而且获取锁的过程中可以中断，此外实现了公平锁机制，可以自己调整锁竞争的公平性，但是由于自己控制加锁和解锁，需要控制好锁的次数，否则造成锁无法释放